# 强制类型转换

### 值类型转换
将值从一种类型转换为另一种类型通常称为**类型转换（type casting）**，这是显式类型转换。隐式的情况称为**强制类型转换（coercion）**。

`JavaScript`中的强制类型转换总是返回**标量基本类型值**。

也可以这样来区分：
> 1. 类型转换发生在静态类型语言的编译阶段；
> 2. 强制类型转换则发生在动态类型语言的运行时。

`JavaScript`中通常统称为**强制类型转换**。

### 抽象值操作
##### **1. toString**
负责处理非字符串到字符串的强制类型转换。

基本类型值的字符串化规则为：`null`转换为`"null"`，`undefined`转换为`"undefined"`，`true`转换为`"true"`。数字的字符串化规则遵循通用规则，不过极小和极大的数字使用指数形式。

对于普通对象来说，除非自行定义，否则`toString()（Object.prototype.toString()）`返回内部属性`[[class]]`的值，如`[object Object]`。

JSON字符串化

##### **2. toNumber**
`true`转换为`1`，`false`转换为`0`。`undefined`转换为`NaN`，`null`转换为`0`。

处理失败时返回`NaN`，对于`0`开头的十六进制数并不按十六进制处理，而是按十进制。

对象会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则其强制转换为数字。

为了将值转换为相应的基本类型值，抽象操作`toPrimitive`会首先（通过内部操作`DefaultValue`）检查该值是否有`valueOf()`方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用`toString()`的返回值（如果存在）来进行强制类型转换。如果`valueOf()`和`toString()`均不返回基本类型值，会产生`TypeError`错误。

使用`Object.create(null)`创建的对象`[[Prototype]]`属性为`null`，并且没有`valueOf()`和`toString()`方法，因此无法进行强制类型转换。

##### **3. toBoolean**
**假值（falsy value）**
>1. 可以被强制类型转换为`false`的值
>
>2. 其他（被强制类型转换为`true`的值）

以下这些是假值：
- `undefined`
- `null`
- `false`
- `+0`、`-0`和`NaN`
- `""`

假值的布尔强制转换结果为`false`。

**假值对象（falsy object）**
```javascript
var a = new Boolean(false);
var b = new Number(0);
var c = new String("");

var d = Boolean(a && b && c);
d; // true
```
这些只是封装了假值的对象。

假值对象看起来和普通对象并无二致，但将他们强制类型转换为布尔值时结果为`false`
```javascript
Boolean(document.all); // false;
```

**真值（truthy value）**

真值是假值列表之外的值

### 显式强制类型转换

**字符串和数字之间的显式转换**
>1. 日期显式转换为数字
> ```javascript
> var d = new Date();
> +d; // 一串数字
> ```
>2. 奇特的~运算符<br>
>首先会将值强制类型转换为32位数字，然后执行位操
>作"非"；`~x`大致等同于`-(x+1)`，如`~42 => -(42+1) = -43`<br>
>在`-(x+1)`中唯一能够得到0的`x`值是`-1`
>```javascript
> var a = "Hello World";
> !~a.indexOf("ol"); // true
> // 这样就不会像`>= 0`和`== -``在代码中暴露底层的实现细节(这种暴露底层细节成为抽象渗漏)
>```
>3. 位截除<br>
>`~~`可以用来截除数字值的小数部分，其执行过程为：第一个`~`执行`ToInt32`并反转位，然后第二个`~`再进行一个位反转。得到的仍然是`ToInt32`的结果。需要注意的是，`~~`只适用于32位数字，其对附属的处理与`Math.floor(...)`是不同的。

**显示解析数字字符串**

解析==允许==字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换==不允许==出现非数字字符，否则会失败并返回`NaN`。
```javascript
parseInt(1/0, 19); // 18
```
这里`1/0`是`Infinity`，实际上执行的就是`parseInt("Infinity", 19)`。第一个字符是`"I"`，以19为基数时值为18。第二个字符`"n"`不是一个有效的数字字符，解析到此为止。

**显示转换为布尔值**

建议使用`Boolean(...)`和`!!`进行显示转换，以便让代码更清晰易读。

**隐式强制类型转换**

作用是减少冗余，让代码更简洁。
- 隐式地简化
- 字符串和数字之间的隐式强制类型转换
    > `a + ""`这样的隐式转化和`String(a)`之间有个细微差别：根据`toPrimitive`抽象操作规则， `a + ""`会对`a`调用`valueOf()`方法，然后通过`toString`抽象操作将返回值转换为字符串。而`String(a)`则是直接调用`toString()`方法
```javascript
[] + {}; // [object Object]
{} + []; // 0
```
- 布尔值到数字的隐式强制类型转换
- 隐式强制类型转换为布尔值

> >1. `if(...)`语句中的条件判断表达式
> >2. `for(...; ...; ...)`语句中的条件判断表达式
> >3. `while(...)`和`do...while(...)`循环中的条件判断表达式
> >4. `? : `三目运算符中的条件判断表达式
> >5. 逻辑运算符`||`和`&&`左边的操作数（作为条件判断表达式）
> 
> 以上情况，非布尔值会被隐式强制类型转换为布尔值，遵循前面的`toBoolean`抽象操作原则
- `||`和`&&`
- 符号的强制类型转换

**宽松相等和严格相等**
- 抽象相等
    >`NaN`不等于`NaN`；`+0`等于`-0`
    >
    > 字符串和数字之间的比较
    > > 如果`x`是数字，`y`是字符串，则返回`x == toNumber(y)`的结果；
    > >
    > > 如果`x`是字符串，`y`是数字，则返回`toNumber(x) == y`的结果
    > 
    > 其他类型和布尔类型之间的相等比较
    >
    > > 如果`x`是布尔类型，则返回`toNumber(x) == y`的结果
    > >
    > > 如果`y`是布尔类型，则返回`x == toNumber(y)`的结果
    >
    > `null`和`undefined`之间的相等比较
    > > `==`中，`null`和`undefined`相等（它们也与其自身相等）
    >
    > 对象和非对象之间的相等比较
    > > 如果`x`是字符串或数字，`y`是对象，则返回`x == toPrimitive(y)`的结果
    > >
    > > 如果`x`是对象，`y`是字符串或数字，则返回`toPrimitive(x) == y`的结果
- 安全运用
    > 如果两边的值中有`true`或者`false`，千万不要使用`==`；
    >
    > 如果两边的值中有`[]`、`""`或者`0`，尽量不要使用`==`。

### 抽象关系比较
